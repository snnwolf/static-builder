// Generated by CoffeeScript 1.8.0

/*
Version: 0.0.1
 */
'use strict';
var EOL, FILE_ENCODING, TMP_DIR, base64replace, clearDir, config, fs, path, plugin, uglify, util;

fs = require('fs');

path = require('path');

util = require('util');

TMP_DIR = '/tmp/';

FILE_ENCODING = 'utf-8';

EOL = "\n";

clearDir = function(dirPath, deleteRoot) {
  var e, filePath, files, i, _i, _len;
  if (deleteRoot == null) {
    deleteRoot = false;
  }
  try {
    files = fs.readdirSync(dirPath);
  } catch (_error) {
    e = _error;
    return;
  }
  if (files.length > 0) {
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      i = files[_i];
      filePath = "" + dirPath + "/" + i;
      if (fs.statSync(filePath).isFile()) {
        fs.unlinkSync(filePath);
      } else {
        clearDir(filePath);
      }
    }
  }
  if (deleteRoot) {
    fs.rmdirSync(dirPath, true);
  }
};

base64replace = function(src, config) {
  var out, rImages;
  if (!Array.isArray(src)) {
    src = [src];
  }
  rImages = /url(?:\(['|"]?)(.*?)(?:['|"]?\))(?!.*\/\*base64:skip\*\/)/ig;
  out = src.map(function(filePath) {
    var code, cssDir, files;
    files = {};
    code = fs.readFileSync(filePath, FILE_ENCODING);
    cssDir = path.dirname(filePath);
    return code.replace(rImages, function(match, file, type) {
      var base64, e, fileName, size;
      if (file.indexOf('/') === 0) {
        fileName = path.normalize("" + config.rootPath + "/" + file);
      } else {
        fileName = path.normalize("" + cssDir + "/" + file);
      }
      if (match.indexOf('data:image') > -1) {
        return match;
      }
      try {
        if (!fs.statSync(fileName).isFile()) {
          console.log("Skip " + fileName + " not is file");
          return match;
        }
      } catch (_error) {
        e = _error;
        console.log("Skip " + fileName + " does not exists");
        return match;
      }
      size = fs.statSync(fileName).size;
      if (type === 'jpg') {
        type = 'jpeg';
      }
      if (type === 'svg') {
        type = 'svg+xml';
      }
      if (size > 4096) {
        return match;
      } else {
        base64 = fs.readFileSync(fileName).toString('base64');
        files[fileName] = true;
        return "url(\"data:image/" + type + ";base64," + base64 + "\")";
      }
    });
  });
  return out.join(EOL);
};

uglify = function(src, type, config) {
  var code, comment, dist, distDir, distFile, ff, md5sum, mincode, uglifyCSS, uglifyJS, _i, _len;
  if (!Array.isArray(src)) {
    src = [src];
  }
  distDir = config.distDir || 'm/';
  if (!distDir || !fs.lstatSync(distDir).isDirectory()) {
    throw new Error("" + distDir + " is not a directory");
  }
  md5sum = require('crypto').createHash('md5');
  code = '';
  switch (type) {
    case 'css':
      uglifyCSS = require('uglifycss');
      code = base64replace(src, config);
      code = uglifyCSS.processString(code);
      break;
    case 'js':
      uglifyJS = require('uglify-js');
      mincode = uglifyJS.minify(src, {
        compress: {
          hoist_funs: false
        }
      });
      code = mincode.code;
      break;
    default:
      throw new Error("" + type + " must bee js|css");
  }
  comment = "/**\n";
  for (_i = 0, _len = src.length; _i < _len; _i++) {
    ff = src[_i];
    comment += " * " + ff + "\n";
  }
  comment += " */";
  distFile = md5sum.update(code).digest('hex').slice(0, 7) + '.' + type;
  dist = path.normalize(distDir + '/' + distFile);
  fs.writeFileSync(dist, "" + comment + "\n" + code, FILE_ENCODING);
  return path.normalize("" + config.baseUrl + "/" + distFile);
};

plugin = {
  build: function(config) {
    var consists_of, l, list_path, package_content, package_idx, part, res, tags_tpl, ugilified, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
    res = {};
    clearDir(config.distDir);
    _ref = config.packages;
    for (package_idx in _ref) {
      package_content = _ref[package_idx];
      res[package_idx] = [];
      tags_tpl = {
        css: "<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">",
        js: "<script type=\"text/javascript\" src=\"%s\">"
      };
      if (package_content.css_ext) {
        _ref1 = package_content.css_ext;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          l = _ref1[_i];
          part = {
            tag: util.format(tags_tpl['css'], l),
            consists_of: [util.format(tags_tpl['css'], l)]
          };
          res[package_idx].push(part);
        }
      }
      if (package_content.js_ext) {
        _ref2 = package_content.js_ext;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          l = _ref2[_j];
          part = {
            tag: util.format(tags_tpl['js'], l),
            consists_of: [util.format(tags_tpl['js'], l)]
          };
          res[package_idx].push(part);
        }
      }
      if (package_content.js) {
        consists_of = [];
        list_path = [];
        _ref3 = package_content.js;
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          l = _ref3[_k];
          list_path.push("" + l.path);
          consists_of.push(util.format(tags_tpl['js'], l.href));
        }
        ugilified = uglify(list_path, 'js', config);
        part = {
          tag: util.format(tags_tpl['js'], ugilified),
          consists_of: consists_of
        };
        res[package_idx].push(part);
      }
      if (package_content.css) {
        consists_of = [];
        list_path = [];
        _ref4 = package_content.css;
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          l = _ref4[_l];
          list_path.push("" + l.path);
          consists_of.push(util.format(tags_tpl['css'], l.href));
        }
        ugilified = uglify(list_path, 'css', config);
        part = {
          tag: util.format(tags_tpl['css'], ugilified),
          consists_of: consists_of
        };
        res[package_idx].push(part);
      }
    }
    fs.writeFileSync('m/build.json', JSON.stringify(res, null, 4), FILE_ENCODING);
  }
};

if (require.main === module) {
  config = require('./builder-config');
  plugin.build(config);
}
